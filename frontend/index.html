<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Synthonnel</title>
    <link rel="stylesheet" href="dragula.min.css" />
    <style>
        .handle {
            cursor: grab;
        }

        #drag-elements {
            display: flex; /* Use flexbox to align children horizontally */
            gap: 10px; /* Optional: adds some space between items */
        }
        #drag-elements div {
            padding: 0px; /* Optional: adds some padding inside each item */
            background-color: #f0f0f0; /* Optional: adds a background color */
            display: flex; /* Enables flexbox layout */
            justify-content: center; /* Centers the item title horizontally */
            position: relative; /* Allows absolute positioning inside */
        }
        /* Add styling for when you're dragging an item */
        .gu-mirror {
            list-style: none;
            margin: 0;
            padding: 0;
            z-index: 9999;
            opacity: 0.8;
        }
        .gu-hide {
            display: none !important;
        }
        .gu-unselectable {
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
        }
        .gu-transit {
            opacity: 0.2;
        }
        #addItemBtn {
            cursor: pointer;
            
            /* Add more styling here */
        }

        #addItemForm {
            /* Ensure the form is visually distinct and easy to use */
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        #userPrompt {
            width: calc(100% - 200px); /* Adjust the subtraction value based on the total width of the side elements */
            margin: 0 auto; /* Center the textarea */
            height: auto; /* Initial height to accommodate 3 lines, but it will be resizable */
            min-height: 30px; /* Roughly 3 lines high depending on font size */
            resize: none; /* Allows vertical resizing */
            position: fixed;
            left: 100px; /* Adjust based on the space needed for the "other stuff" on the left */
            bottom: 10px; /* Adjust as needed to not overlap with your button */
        }
        #trashcan.highlight {
            background-color: #f88; /* Highlight color, choose as per your UI theme */
            transition: background-color 0.3s; /* Smooth transition for the color change */
        }
        .item {
            display: flex; /* Enables Flexbox */
            flex-direction: column; /* Stacks children vertically */
            gap: 8px; /* Optional: Adds some space between the children */
            padding: 0px; /* Optional: Adds some padding inside each item */
            border: 1px solid #ccc; /* Optional: Adds a border around each item */
            margin-bottom: 10px; /* Optional: Adds space between items */
            flex-grow: 1; /* Allows the title to fill the space */
            width: 100%; /* Ensures the item takes up the full width */
        }
        .itemTitle {
            font-weight: bold; /* Optional: Makes the title stand out */
            margin-bottom: 4px; /* Ensures space between the title and the response */
            text-align: center; /* Ensures the title text is centered */
            border: 1px solid #ccc; /* Optional: Adds a border around each item */
            width: 100%; /* Ensures the item takes up the full width */
            padding-top: 5px;
            padding-bottom: 5px;
        }
        .response {
            flex-grow: 1;
            border: none;
            padding: 10px;
            text-align: left;
        }

    </style>
</head>
<body>
    <div id="drag-elements"></div>
    <div id="trashcan"          style="position: fixed; left: 20px; bottom: 16px; font-size: 24px;">üóëÔ∏è</div>
    <button id="addItemBtn"     style="position: fixed; left: 60px; bottom: 16px; font-size: 24px; border: none;">+</button>
    <textarea id="userPrompt"   style="width: calc(100% - 200px); min-height: 30px; overflow-y: hidden;" placeholder="Enter your prompt here..."></textarea>
    <button id="submitPrompt"   style="position: fixed; right: 30px; bottom: 16px; font-size: 24px; border: none;">ü†â</button>

    <!-- Hidden form for adding items -->
    <div id="addItemFormHider" style="display:none">
        <div id="addItemForm" style="position: fixed; left: 20px; bottom: 80px; background: white; padding: 10px; border: 1px solid #ccc; display: grid; gap: 10px;">
            <input type="text" id="newItemProvider" placeholder="Provider">
            <input type="text" id="newItemModel" placeholder="Model">
            <textarea id="newItemParameters" placeholder="Parameters" rows="4" style="resize: vertical;"></textarea>
            <input type="text" id="newItemProviderUrl" placeholder="ProviderUrl">
            <input type="text" id="newItemApiKey" placeholder="ApiKey">
            <button id="confirmAddItem">Add</button>
        </div>
    </div>
    <script src="dragula.min.js"></script>
    <script>
        // Initialize Dragula
        var drake = dragula([document.getElementById('drag-elements')], {
                moves: function (el, container, handle) {
                    return handle.classList.contains('handle');
                }
            });

        let droppedOnTrashcan = false;

        drake.on('drop', (el, target) => {
            if (!droppedOnTrashcan && target) {
                // Item was not dropped on the trashcan and has a valid target container
                saveItems();
            }
            // Reset the flag
            droppedOnTrashcan = false;
        });

        drake.on('dragend', (el) => {
            const trashcan = document.getElementById('trashcan');
            const trashRect = trashcan.getBoundingClientRect();
            const elRect = el.getBoundingClientRect();

            const overlaps = !(elRect.right < trashRect.left || 
                                elRect.left > trashRect.right || 
                                elRect.bottom < trashRect.top || 
                                elRect.top > trashRect.bottom);

            if (overlaps) {
                // If the item overlaps the trashcan, mark it for deletion
                droppedOnTrashcan = true;
                // Remove the item
                el.parentNode.removeChild(el);
                // Optionally, call saveItems() here if you want to immediately save the state after deletion
            }
        });

        let isOverTrashcan = false; // Flag to track when an item is over the trashcan

        drake.on('drag', (el, source) => {
            document.addEventListener('mousemove', onMouseMove);
        });

        drake.on('dragend', (el) => {
            document.removeEventListener('mousemove', onMouseMove);
            const trashcan = document.getElementById('trashcan');
            trashcan.classList.remove('highlight'); // Always remove highlight on drag end
            
            if (isOverTrashcan) {
                // Handle item deletion
                el.parentNode.removeChild(el);
                isOverTrashcan = false; // Reset flag
                // Optionally, save the state here if you want
                saveItems();
            }
        });

        function onMouseMove(event) {
            const trashcan = document.getElementById('trashcan');
            const trashRect = trashcan.getBoundingClientRect();
            const isMouseOverTrashcan = event.clientX >= trashRect.left && event.clientX <= trashRect.right &&
                                        event.clientY >= trashRect.top && event.clientY <= trashRect.bottom;
            
            if (isMouseOverTrashcan && !isOverTrashcan) {
                trashcan.classList.add('highlight');
                isOverTrashcan = true;
            } else if (!isMouseOverTrashcan && isOverTrashcan) {
                trashcan.classList.remove('highlight');
                isOverTrashcan = false;
            }
        }

        document.getElementById('addItemBtn').onclick = function() {
            if (document.getElementById('addItemFormHider').style.display == 'block') {
                document.getElementById('addItemFormHider').style.display = 'none'
            } else {
                document.getElementById('addItemFormHider').style.display = 'block';
            }
        };

        document.getElementById('confirmAddItem').onclick = async function() {
            const newItemProvider = document.getElementById('newItemProvider').value.trim();
            const newItemModel = document.getElementById('newItemModel').value.trim();
            const newItemParameters = document.getElementById('newItemParameters').value.trim();
            const newItemProviderUrl = document.getElementById('newItemProviderUrl').value.trim();
            const newItemApiKey = document.getElementById('newItemApiKey').value.trim();
            
            if (newItemProvider && newItemModel && newItemProviderUrl && newItemApiKey) {
                const newItemHTML = `
                    <div class="item" 
                        data-provider="${newItemProvider}" 
                        data-model="${newItemModel}" 
                        data-parameters="${newItemParameters}" 
                        data-providerurl="${newItemProviderUrl}" 
                        data-apikey="${newItemApiKey}">
                        <div class="itemTitle handle">${newItemProvider}</div>
                        <div class="response"></div>
                    </div>
                `;

                document.getElementById('drag-elements').insertAdjacentHTML('beforeend', newItemHTML);

                // Reset form
                // document.getElementById('newItemTitle').value = '';
                // document.getElementById('newItemProvider').value = '';
                // document.getElementById('newItemModel').value = '';
                // document.getElementById('newItemTemperature').value = '';
                // document.getElementById('addItemForm').style.display = 'none';

                saveItems();
            }
        };

        async function saveItems() {
            const items = Array.from(document.querySelectorAll('#drag-elements .item')).map(div => ({
                provider: div.dataset.provider,
                model: div.dataset.model,
                parameters: div.dataset.parameters,
                providerurl: div.dataset.providerurl,
                apikey: div.dataset.apikey,
            }));

            fetch('http://localhost:8000/save-items', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(items),
            });
        }

        document.addEventListener('DOMContentLoaded', (event) => {
            fetchItemsAndPopulateUI();
        });

        async function fetchItemsAndPopulateUI() {
            try {
                const response = await fetch('http://localhost:8000/get-items');
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                const items = await response.json();
                
                const container = document.getElementById('drag-elements');
                container.innerHTML = ''; // Clear existing items, if necessary
                
                items.forEach(item => {
                    const div = document.createElement('div');
                    div.className = 'item';
                    div.setAttribute('data-provider', item.provider);
                    div.setAttribute('data-model', item.model);
                    div.setAttribute('data-parameters', item.parameters);
                    div.setAttribute('data-providerurl', item.providerurl);
                    div.setAttribute('data-apikey', item.apikey);

                    div.innerHTML = `<div class="itemTitle handle">${item.provider}</div><div class="response"></div>`;
                    
                    container.appendChild(div);
                });
                
                // Re-initialize drag-and-drop functionality if needed
            } catch (error) {
                console.error('Failed to fetch items:', error);
            }
        }

        document.addEventListener('DOMContentLoaded', function () {
            const textarea = document.getElementById('userPrompt');
            
            function autoGrowTextArea(textAreaElement) {
                // Reset the height to ensure we're not perpetually growing
                textAreaElement.style.height = 'auto';
                // Set the height to scrollHeight to include the height of the overflow text
                textAreaElement.style.height = `${textAreaElement.scrollHeight}px`;
            }
            
            // Listen for input event on the textarea
            textarea.addEventListener('input', function() {
                autoGrowTextArea(this);
            });

            // Initial call in case of any pre-filled value when the page loads
            autoGrowTextArea(textarea);
        });

        document.getElementById('submitPrompt').addEventListener('click', function() {
            const prompt = document.getElementById('userPrompt').value;
            const items = Array.from(document.querySelectorAll('.item'));

            items.forEach((item) => {
                const ws = new WebSocket(`ws://localhost:8000/ws/stream-llm-response`);

                ws.onopen = function(event) {
                    // Prepare item parameters
                    const itemData = {
                        prompt: prompt,
                        provider: item.dataset.provider,
                        model: item.dataset.model,
                        parameters: item.dataset.parameters,
                        providerUrl: item.dataset.providerurl,
                        apiKey: item.dataset.apikey
                    };
                    // Send the item parameters after connection opens
                    ws.send(JSON.stringify(itemData));
                };

                ws.onmessage = function(event) {
                    const responseContainer = item.querySelector('.response');
                    responseContainer.textContent += event.data + ' ';
                };

                ws.onerror = function(event) {
                    console.error("WebSocket error observed:", event);
                };

                ws.onclose = function(event) {
                    console.log("WebSocket connection closed.");
                };
            });
        });

    </script>
</body>
</html>
