<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Synthonnel</title>
    <link rel="stylesheet" href="dragula.min.css" />
    <style>
        .handle {
            cursor: grab;
        }

        #drag-elements {
            display: flex;
            gap: 10px;
        }
        #drag-elements div {
            padding: 0px;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            position: relative;
        }
        .gu-mirror {
            list-style: none;
            margin: 0;
            padding: 0;
            z-index: 9999;
            opacity: 0.8;
        }
        .gu-hide {
            display: none !important;
        }
        .gu-unselectable {
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
        }
        .gu-transit {
            opacity: 0.2;
        }
        #addItemBtn {
            cursor: pointer;
        }

        #addItemForm {
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        #userPrompt {
            width: calc(100% - 200px);
            margin: 0 auto;
            height: auto;
            min-height: 30px;
            resize: none;
            position: fixed;
            left: 100px;
            bottom: 10px;
        }
        #trashcan.highlight {
            background-color: #f88;
            transition: background-color 0.3s;
        }
        .item {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 0px;
            border: 1px solid #ccc;
            margin-bottom: 10px;
            flex-grow: 1;
            width: 100%;
        }
        .itemTitle {
            font-weight: bold;
            margin-bottom: 4px;
            text-align: center;
            border: 1px solid #ccc;
            width: 100%;
            padding-top: 5px;
            padding-bottom: 5px;
        }
        .response {
            flex-grow: 1;
            border: none;
            padding: 10px;
            text-align: left;
        }

    </style>
</head>
<body>
    <div id="drag-elements"></div>
    <div id="trashcan"          style="position: fixed; left: 20px; bottom: 16px; font-size: 24px;">üóëÔ∏è</div>
    <button id="addItemBtn"     style="position: fixed; left: 60px; bottom: 16px; font-size: 24px; border: none;">+</button>
    <textarea id="userPrompt"   style="width: calc(100% - 200px); min-height: 30px; overflow-y: hidden;" placeholder="Enter your prompt here..."></textarea>
    <button id="submitPrompt"   style="position: fixed; right: 30px; bottom: 16px; font-size: 24px; border: none;">ü†â</button>

    <div id="addItemFormHider" style="display:none">
        <div id="addItemForm" style="position: fixed; left: 20px; bottom: 80px; background: white; padding: 10px; border: 1px solid #ccc; display: grid; gap: 10px;">
            <input type="text" id="newItemProvider" placeholder="Provider">
            <input type="text" id="newItemModel" placeholder="Model">
            <textarea id="newItemParameters" placeholder="Parameters" rows="4" style="resize: vertical;"></textarea>
            <input type="text" id="newItemProviderUrl" placeholder="ProviderUrl">
            <input type="text" id="newItemApiKey" placeholder="ApiKey">
            <button id="confirmAddItem">Add</button>
        </div>
    </div>
    <script src="dragula.min.js"></script>
    <script>
        var drake = dragula([document.getElementById('drag-elements')], {
                moves: function (el, container, handle) {
                    return handle.classList.contains('handle');
                }
            });

        let droppedOnTrashcan = false;

        drake.on('drop', (el, target) => {
            if (!droppedOnTrashcan && target) {
                saveItems();
            }
            droppedOnTrashcan = false;
        });

        drake.on('dragend', (el) => {
            const trashcan = document.getElementById('trashcan');
            const trashRect = trashcan.getBoundingClientRect();
            const elRect = el.getBoundingClientRect();

            const overlaps = !(elRect.right < trashRect.left || 
                                elRect.left > trashRect.right || 
                                elRect.bottom < trashRect.top || 
                                elRect.top > trashRect.bottom);

            if (overlaps) {
                droppedOnTrashcan = true;
                el.parentNode.removeChild(el);
            }
        });

        let isOverTrashcan = false;

        drake.on('drag', (el, source) => {
            document.addEventListener('mousemove', onMouseMove);
        });

        drake.on('dragend', (el) => {
            document.removeEventListener('mousemove', onMouseMove);
            const trashcan = document.getElementById('trashcan');
            trashcan.classList.remove('highlight');
            
            if (isOverTrashcan) {
                el.parentNode.removeChild(el);
                isOverTrashcan = false;
                saveItems();
            }
        });

        function onMouseMove(event) {
            const trashcan = document.getElementById('trashcan');
            const trashRect = trashcan.getBoundingClientRect();
            const isMouseOverTrashcan = event.clientX >= trashRect.left && event.clientX <= trashRect.right &&
                                        event.clientY >= trashRect.top && event.clientY <= trashRect.bottom;
            
            if (isMouseOverTrashcan && !isOverTrashcan) {
                trashcan.classList.add('highlight');
                isOverTrashcan = true;
            } else if (!isMouseOverTrashcan && isOverTrashcan) {
                trashcan.classList.remove('highlight');
                isOverTrashcan = false;
            }
        }

        document.getElementById('addItemBtn').onclick = function() {
            if (document.getElementById('addItemFormHider').style.display == 'block') {
                document.getElementById('addItemFormHider').style.display = 'none'
            } else {
                document.getElementById('addItemFormHider').style.display = 'block';
            }
        };

        document.getElementById('confirmAddItem').onclick = async function() {
            const newItemProvider = document.getElementById('newItemProvider').value.trim();
            const newItemModel = document.getElementById('newItemModel').value.trim();
            const newItemParameters = document.getElementById('newItemParameters').value.trim();
            const newItemProviderUrl = document.getElementById('newItemProviderUrl').value.trim();
            const newItemApiKey = document.getElementById('newItemApiKey').value.trim();
            
            if (newItemProvider && newItemModel && newItemProviderUrl && newItemApiKey) {
                const newItemHTML = `
                    <div class="item" 
                        data-provider="${newItemProvider}" 
                        data-model="${newItemModel}" 
                        data-parameters="${newItemParameters}" 
                        data-providerurl="${newItemProviderUrl}" 
                        data-apikey="${newItemApiKey}">
                        <div class="itemTitle handle">${newItemProvider}</div>
                        <div class="response"></div>
                    </div>
                `;

                document.getElementById('drag-elements').insertAdjacentHTML('beforeend', newItemHTML);

                // Reset form
                // document.getElementById('newItemTitle').value = '';
                // document.getElementById('newItemProvider').value = '';
                // document.getElementById('newItemModel').value = '';
                // document.getElementById('newItemTemperature').value = '';
                // document.getElementById('addItemForm').style.display = 'none';

                saveItems();
            }
        };

        async function saveItems() {
            const items = Array.from(document.querySelectorAll('#drag-elements .item')).map(div => ({
                provider: div.dataset.provider,
                model: div.dataset.model,
                parameters: div.dataset.parameters,
                providerurl: div.dataset.providerurl,
                apikey: div.dataset.apikey,
            }));

            fetch('http://localhost:8000/save-items', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(items),
            });
        }

        document.addEventListener('DOMContentLoaded', (event) => {
            fetchItemsAndPopulateUI();
        });

        async function fetchItemsAndPopulateUI() {
            try {
                const response = await fetch('http://localhost:8000/get-items');
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                const items = await response.json();
                
                const container = document.getElementById('drag-elements');
                container.innerHTML = '';
                
                items.forEach(item => {
                    const div = document.createElement('div');
                    div.className = 'item';
                    div.setAttribute('data-provider', item.provider);
                    div.setAttribute('data-model', item.model);
                    div.setAttribute('data-parameters', item.parameters);
                    div.setAttribute('data-providerurl', item.providerurl);
                    div.setAttribute('data-apikey', item.apikey);

                    div.innerHTML = `<div class="itemTitle handle">${item.provider}</div><div class="response"></div>`;
                    
                    container.appendChild(div);
                });
            } catch (error) {
                console.error('Failed to fetch items:', error);
            }
        }

        document.addEventListener('DOMContentLoaded', function () {
            const textarea = document.getElementById('userPrompt');
            
            function autoGrowTextArea(textAreaElement) {
                textAreaElement.style.height = 'auto';
                textAreaElement.style.height = `${textAreaElement.scrollHeight}px`;
            }
            
            textarea.addEventListener('input', function() {
                autoGrowTextArea(this);
            });

            autoGrowTextArea(textarea);
        });

        document.getElementById('submitPrompt').addEventListener('click', function() {
            const prompt = document.getElementById('userPrompt').value;
            const items = Array.from(document.querySelectorAll('.item'));

            items.forEach((item) => {
                const ws = new WebSocket(`ws://localhost:8000/ws/stream-llm-response`);

                ws.onopen = function(event) {
                    const itemData = {
                        prompt: prompt,
                        provider: item.dataset.provider,
                        model: item.dataset.model,
                        parameters: item.dataset.parameters,
                        providerUrl: item.dataset.providerurl,
                        apiKey: item.dataset.apikey
                    };
                    ws.send(JSON.stringify(itemData));
                };

                ws.onmessage = function(event) {
                    const responseContainer = item.querySelector('.response');
                    responseContainer.textContent += event.data + ' ';
                };

                ws.onerror = function(event) {
                    console.error("WebSocket error observed:", event);
                };

                ws.onclose = function(event) {
                    console.log("WebSocket connection closed.");
                };
            });
        });

    </script>
</body>
</html>
